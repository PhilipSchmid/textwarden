// StyleTypes+Generable.swift
// Foundation Models @Generable types for style analysis

import Foundation

#if canImport(FoundationModels)
import FoundationModels

// MARK: - @Generable Types for Foundation Models

/// A style improvement suggestion generated by Foundation Models
@available(macOS 26.0, *)
@Generable
struct FMStyleSuggestion {
    @Guide(description: """
        The exact phrase from the input text that should be improved.
        Must be a verbatim substring - character-for-character match.
        """)
    let original: String

    @Guide(description: """
        The improved version of the phrase.
        MUST be different from original - never return identical text.
        Must maintain the same meaning while improving style.
        """)
    let suggested: String

    @Guide(description: """
        One short sentence explaining why this improves readability.
        Maximum 10 words. Be direct, no filler words.
        Example: "Removes redundant phrasing for clarity."
        """)
    let explanation: String
}

/// Result of Foundation Models style analysis
@available(macOS 26.0, *)
@Generable
struct FMStyleAnalysisResult {
    @Guide(description: """
        List of style improvement suggestions.
        Return empty array [] if the text is already well-written.
        Order by impact (most important first).
        Maximum 5 suggestions per analysis.
        """)
    let suggestions: [FMStyleSuggestion]
}

// MARK: - Conversion to App Types

@available(macOS 26.0, *)
extension FMStyleSuggestion {
    /// Convert to StyleSuggestionModel for use in the app
    /// - Parameters:
    ///   - text: The original text that was analyzed (for position calculation)
    ///   - style: The writing style that was used
    /// - Returns: A StyleSuggestionModel, or nil if the original text wasn't found or suggestion is invalid
    func toStyleSuggestionModel(in text: String, style: WritingStyle) -> StyleSuggestionModel? {
        // Log suggestion metadata (not content to avoid logging sensitive user text)
        Logger.debug("Style suggestion - original: \(original.count) chars, suggested: \(suggested.count) chars", category: Logger.analysis)

        // Reject suggestions where original and suggested are identical (no actual change)
        // This handles AI hallucinations where it detects an issue but doesn't provide a real fix
        let normalizedOriginal = original.trimmingCharacters(in: .whitespacesAndNewlines)
        let normalizedSuggested = suggested.trimmingCharacters(in: .whitespacesAndNewlines)
        if normalizedOriginal == normalizedSuggested {
            Logger.debug("Style suggestion rejected - original and suggested text are identical (AI hallucination)", category: Logger.analysis)
            return nil
        }

        // Find the position of the original text in the input
        guard let range = text.range(of: original) else {
            Logger.debug("Style suggestion rejected - original text not found in input", category: Logger.analysis)
            return nil
        }

        // Reject suggestions that span multiple list items/bullets
        // Count newlines in original text - if there's more than one significant paragraph break, reject
        let newlineCount = original.components(separatedBy: "\n").count - 1
        if newlineCount >= 2 {
            Logger.debug("Rejecting style suggestion spanning \(newlineCount + 1) paragraphs (\(original.count) chars)", category: Logger.analysis)
            return nil
        }

        let startIndex = text.distance(from: text.startIndex, to: range.lowerBound)
        let endIndex = text.distance(from: text.startIndex, to: range.upperBound)

        // Build diff segments
        let diff = buildDiffSegments(original: original, suggested: suggested)

        // Log diff segment counts (not content to avoid logging sensitive user text)
        let addedCount = diff.filter { $0.kind == .added }.count
        let removedCount = diff.filter { $0.kind == .removed }.count
        let unchangedCount = diff.filter { $0.kind == .unchanged }.count
        Logger.debug("Style suggestion diff: \(diff.count) segments (added: \(addedCount), removed: \(removedCount), unchanged: \(unchangedCount))", category: Logger.analysis)

        return StyleSuggestionModel(
            id: UUID().uuidString,
            originalStart: startIndex,
            originalEnd: endIndex,
            originalText: original,
            suggestedText: suggested,
            explanation: explanation,
            confidence: 0.85,  // FM suggestions are high quality
            style: style,
            diff: diff
        )
    }

    /// Build diff segments showing what changed between original and suggested
    /// Uses Swift's built-in CollectionDifference with Myers's algorithm
    private func buildDiffSegments(original: String, suggested: String) -> [DiffSegmentModel] {
        // Normalize quotes before diffing to avoid false positives from smart quotes
        let normalizedOriginal = normalizeQuotes(original)
        let normalizedSuggested = normalizeQuotes(suggested)

        // Split into words, preserving whitespace with each word
        let originalWords = splitIntoWords(normalizedOriginal)
        let suggestedWords = splitIntoWords(normalizedSuggested)

        // Use Swift's built-in diff (Myers's algorithm)
        let diff = suggestedWords.difference(from: originalWords)

        // Build a map of changes by index
        var removals: Set<Int> = []
        var insertions: [Int: String] = [:]

        for change in diff {
            switch change {
            case .remove(let offset, _, _):
                removals.insert(offset)
            case .insert(let offset, let element, _):
                insertions[offset] = element
            }
        }

        // Build segments by walking through both arrays
        var segments: [DiffSegmentModel] = []
        var origIdx = 0
        var suggIdx = 0

        while origIdx < originalWords.count || suggIdx < suggestedWords.count {
            // Handle insertions at current suggested position
            if let inserted = insertions[suggIdx] {
                segments.append(DiffSegmentModel(text: inserted, kind: .added))
                suggIdx += 1
                continue
            }

            // Handle removals at current original position
            if origIdx < originalWords.count && removals.contains(origIdx) {
                segments.append(DiffSegmentModel(text: originalWords[origIdx], kind: .removed))
                origIdx += 1
                continue
            }

            // Unchanged word
            if origIdx < originalWords.count && suggIdx < suggestedWords.count {
                segments.append(DiffSegmentModel(text: suggestedWords[suggIdx], kind: .unchanged))
                origIdx += 1
                suggIdx += 1
            } else {
                break
            }
        }

        // Merge consecutive segments of the same kind
        return mergeSegments(segments)
    }

    /// Split text into words, each word includes trailing whitespace
    private func splitIntoWords(_ text: String) -> [String] {
        var words: [String] = []
        var current = ""

        for char in text {
            if char.isWhitespace {
                current.append(char)
            } else {
                if !current.isEmpty && current.last?.isWhitespace == true {
                    // Previous was whitespace, start new word but keep whitespace with previous
                    words.append(current)
                    current = String(char)
                } else {
                    current.append(char)
                }
            }
        }

        if !current.isEmpty {
            words.append(current)
        }

        return words
    }

    /// Merge consecutive segments of the same kind for cleaner display
    private func mergeSegments(_ segments: [DiffSegmentModel]) -> [DiffSegmentModel] {
        guard !segments.isEmpty else { return [] }

        var result: [DiffSegmentModel] = []
        var current = segments[0]

        for segment in segments.dropFirst() {
            if segment.kind == current.kind {
                current = DiffSegmentModel(text: current.text + segment.text, kind: current.kind)
            } else {
                result.append(current)
                current = segment
            }
        }
        result.append(current)

        return result
    }

    /// Normalize smart quotes and other typography to plain ASCII equivalents
    /// This prevents false diff positives from quote style differences
    private func normalizeQuotes(_ text: String) -> String {
        var result = text
        // Smart single quotes to straight apostrophe
        result = result.replacingOccurrences(of: "\u{2019}", with: "'")  // Right single quote
        result = result.replacingOccurrences(of: "\u{2018}", with: "'")  // Left single quote
        result = result.replacingOccurrences(of: "\u{201B}", with: "'")  // Single high-reversed-9
        // Smart double quotes to straight quote
        result = result.replacingOccurrences(of: "\u{201C}", with: "\"") // Left double quote
        result = result.replacingOccurrences(of: "\u{201D}", with: "\"") // Right double quote
        result = result.replacingOccurrences(of: "\u{201E}", with: "\"") // Double low-9
        // Dashes to hyphen
        result = result.replacingOccurrences(of: "\u{2013}", with: "-")  // En dash
        result = result.replacingOccurrences(of: "\u{2014}", with: "-")  // Em dash
        return result
    }
}

@available(macOS 26.0, *)
extension FMStyleAnalysisResult {
    /// Convert all suggestions to StyleSuggestionModel array
    /// - Parameters:
    ///   - text: The original text that was analyzed
    ///   - style: The writing style that was used
    /// - Returns: Array of valid StyleSuggestionModel (filtering out any with invalid positions and overlapping ranges)
    func toStyleSuggestionModels(in text: String, style: WritingStyle) -> [StyleSuggestionModel] {
        // Convert all suggestions to models
        let allModels = suggestions.compactMap { $0.toStyleSuggestionModel(in: text, style: style) }

        // Filter out overlapping suggestions
        // When suggestions overlap, keep the first one (by position) and discard overlapping ones
        return filterOverlappingSuggestions(allModels)
    }

    /// Filter out suggestions that overlap with each other
    /// Keeps suggestions in position order, discarding any that overlap with already-kept suggestions
    private func filterOverlappingSuggestions(_ suggestions: [StyleSuggestionModel]) -> [StyleSuggestionModel] {
        guard suggestions.count > 1 else { return suggestions }

        // Sort by start position
        let sorted = suggestions.sorted { $0.originalStart < $1.originalStart }

        var result: [StyleSuggestionModel] = []

        for suggestion in sorted {
            // Check if this suggestion overlaps with any already-kept suggestion
            let overlaps = result.contains { existing in
                rangesOverlap(
                    start1: existing.originalStart, end1: existing.originalEnd,
                    start2: suggestion.originalStart, end2: suggestion.originalEnd
                )
            }

            if !overlaps {
                result.append(suggestion)
            } else {
                Logger.debug("Filtering overlapping style suggestion at \(suggestion.originalStart)-\(suggestion.originalEnd)", category: Logger.analysis)
            }
        }

        return result
    }

    /// Check if two ranges overlap
    /// Ranges are [start, end) - end is exclusive
    private func rangesOverlap(start1: Int, end1: Int, start2: Int, end2: Int) -> Bool {
        // Two ranges overlap if start1 < end2 AND start2 < end1
        return start1 < end2 && start2 < end1
    }
}

#endif
