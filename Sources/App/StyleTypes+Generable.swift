// StyleTypes+Generable.swift
// Foundation Models @Generable types for style analysis and text generation

import Foundation

// MARK: - Text Generation Context Types

/// Source of context for text generation
enum ContextSource {
    case selection // User selected text
    case cursorWindow // Window around cursor
    case documentStart // Beginning of document (short docs)
    case none // No context available
}

/// Context extraction result for text generation
struct GenerationContext {
    let selectedText: String? // If user has selection
    let surroundingText: String? // Text window around cursor
    let fullTextLength: Int // Total document length
    let cursorPosition: Int? // Cursor position in document
    let source: ContextSource // Where context came from

    /// Whether any context is available
    var hasContext: Bool {
        selectedText != nil || surroundingText != nil
    }

    /// A preview of the context for display (truncated)
    var preview: String {
        if let selected = selectedText, !selected.isEmpty {
            let truncated = selected.prefix(100)
            return truncated.count < selected.count ? "\(truncated)..." : String(truncated)
        }
        if let surrounding = surroundingText, !surrounding.isEmpty {
            let truncated = surrounding.prefix(100)
            return truncated.count < surrounding.count ? "\(truncated)..." : String(truncated)
        }
        return ""
    }

    /// Empty context
    static var empty: GenerationContext {
        GenerationContext(
            selectedText: nil,
            surroundingText: nil,
            fullTextLength: 0,
            cursorPosition: nil,
            source: .none
        )
    }
}

#if canImport(FoundationModels)
    import FoundationModels

    // MARK: - @Generable Types for Foundation Models

    /// A style improvement suggestion generated by Foundation Models
    @available(macOS 26.0, *)
    @Generable
    struct FMStyleSuggestion {
        @Guide(description: """
        The exact phrase from the input text that should be improved.
        Must be a verbatim substring - character-for-character match.
        """)
        let original: String

        @Guide(description: """
        The improved version of the phrase.
        MUST be different from original - never return identical text.
        Must maintain the same meaning while improving style.
        """)
        let suggested: String

        @Guide(description: """
        A brief reason why this change improves the text.
        STRICT RULES:
        - Maximum 10 words total
        - Do NOT quote or include the original text
        - Do NOT quote or include the suggested text
        - Do NOT use patterns like "Replaces X with Y"
        - Just explain the benefit (e.g., "Removes redundant words", "More direct phrasing")
        """)
        let explanation: String
    }

    /// Result of Foundation Models style analysis
    @available(macOS 26.0, *)
    @Generable
    struct FMStyleAnalysisResult {
        @Guide(description: """
        List of style improvement suggestions.
        Return empty array [] if the text is already well-written.
        Order by impact (most important first).
        Maximum 5 suggestions per analysis.
        """)
        let suggestions: [FMStyleSuggestion]
    }

    // MARK: - Conversion to App Types

    @available(macOS 26.0, *)
    extension FMStyleSuggestion {
        /// Convert to StyleSuggestionModel for use in the app
        /// - Parameters:
        ///   - text: The original text that was analyzed (for position calculation)
        ///   - style: The writing style that was used
        /// - Returns: A StyleSuggestionModel, or nil if the original text wasn't found or suggestion is invalid
        func toStyleSuggestionModel(in text: String, style: WritingStyle) -> StyleSuggestionModel? {
            // Log suggestion metadata (not content to avoid logging sensitive user text)
            Logger.debug("Style suggestion - original: \(original.count) chars, suggested: \(suggested.count) chars", category: Logger.analysis)

            // Reject suggestions where original and suggested are identical (no actual change)
            // This handles AI hallucinations where it detects an issue but doesn't provide a real fix
            let normalizedOriginal = original.trimmingCharacters(in: .whitespacesAndNewlines)
            let normalizedSuggested = suggested.trimmingCharacters(in: .whitespacesAndNewlines)
            if normalizedOriginal == normalizedSuggested {
                Logger.debug("Style suggestion rejected - original and suggested text are identical (AI hallucination)", category: Logger.analysis)
                return nil
            }

            // Reject suggestions with very short original text (likely AI hallucination or garbage)
            // A meaningful style suggestion should have at least a few words
            if normalizedOriginal.count < 5 {
                Logger.debug("Style suggestion rejected - original text too short (\(normalizedOriginal.count) chars)", category: Logger.analysis)
                return nil
            }

            // Find the position of the original text in the input
            guard let range = text.range(of: original) else {
                Logger.debug("Style suggestion rejected - original text not found in input", category: Logger.analysis)
                return nil
            }

            // CRITICAL: Reject suggestions that appear to be truncated mid-sentence
            // This catches cases where the LLM treats "?" or "!" inside parentheses as sentence end
            // e.g., "soon (next week?) to discuss..." â†’ LLM returns "soon (next week?)" as complete
            let trimmedOriginal = normalizedOriginal.trimmingCharacters(in: .whitespaces)
            if trimmedOriginal.hasSuffix("?)") || trimmedOriginal.hasSuffix("!)") || trimmedOriginal.hasSuffix(".)") {
                // Check if there's more text after this in the document
                if range.upperBound < text.endIndex {
                    // Get the next few characters after the match
                    let remainingStart = range.upperBound
                    let remainingEnd = text.index(remainingStart, offsetBy: min(20, text.distance(from: remainingStart, to: text.endIndex)))
                    let nextChars = String(text[remainingStart ..< remainingEnd]).trimmingCharacters(in: .whitespaces)

                    // If next chars start with lowercase letter, this is a truncated sentence
                    if let firstChar = nextChars.first, firstChar.isLetter, firstChar.isLowercase {
                        Logger.debug("Style suggestion rejected - appears truncated (ends with parenthetical punctuation but sentence continues with '\(nextChars.prefix(10))...')", category: Logger.analysis)
                        return nil
                    }
                }
            }

            // Reject suggestions that span multiple list items/bullets
            // Count newlines in original text - if there's more than one significant paragraph break, reject
            let newlineCount = original.components(separatedBy: "\n").count - 1
            if newlineCount >= 2 {
                Logger.debug("Rejecting style suggestion spanning \(newlineCount + 1) paragraphs (\(original.count) chars)", category: Logger.analysis)
                return nil
            }

            // Sanitize overly long or verbose explanations
            // The model sometimes ignores the "max 10 words" instruction and echoes back the text
            let sanitizedExplanation = sanitizeExplanation(explanation, original: original, suggested: suggested)

            let startIndex = text.distance(from: text.startIndex, to: range.lowerBound)
            let endIndex = text.distance(from: text.startIndex, to: range.upperBound)

            // DIAGNOSTIC: Check for grapheme/UTF-16 mismatch in the prefix
            let prefixText = String(text[..<range.lowerBound])
            let prefixUtf16 = (prefixText as NSString).length
            if startIndex != prefixUtf16 {
                Logger.warning("STYLE_GEN: Position grapheme/UTF-16 mismatch! grapheme=\(startIndex) vs utf16=\(prefixUtf16) (diff: \(prefixUtf16 - startIndex))", category: Logger.analysis)
            }
            Logger.debug("STYLE_GEN: Position for '\(original.prefix(40))...' = \(startIndex)-\(endIndex) (grapheme clusters)", category: Logger.analysis)

            // Build diff segments
            let diff = buildDiffSegments(original: original, suggested: suggested)

            // Log diff segment counts (not content to avoid logging sensitive user text)
            let addedCount = diff.count(where: { $0.kind == .added })
            let removedCount = diff.count(where: { $0.kind == .removed })
            let unchangedCount = diff.count(where: { $0.kind == .unchanged })
            Logger.debug("Style suggestion diff: \(diff.count) segments (added: \(addedCount), removed: \(removedCount), unchanged: \(unchangedCount))", category: Logger.analysis)

            return StyleSuggestionModel(
                id: UUID().uuidString,
                originalStart: startIndex,
                originalEnd: endIndex,
                originalText: original,
                suggestedText: suggested,
                explanation: sanitizedExplanation,
                confidence: 0.85, // FM suggestions are high quality
                style: style,
                diff: diff
            )
        }

        /// Sanitize an explanation that may be too long or contain echoed text
        /// Returns a cleaned version or a generic fallback
        private func sanitizeExplanation(_ explanation: String, original: String, suggested: String) -> String {
            let trimmed = explanation.trimmingCharacters(in: .whitespacesAndNewlines)

            // Count words (split by whitespace)
            let words = trimmed.split(separator: " ", omittingEmptySubsequences: true)
            let wordCount = words.count

            // Check for patterns that indicate echoed text
            let lowerExplanation = trimmed.lowercased()
            let hasQuotes = trimmed.contains("\"")
            let hasReplacesPattern = lowerExplanation.contains("replaces") || lowerExplanation.contains("replaced")
            let containsOriginal = trimmed.contains(original.prefix(20))
            let containsSuggested = trimmed.contains(suggested.prefix(20))

            // If explanation is clean and short, use it as-is
            if wordCount <= 15, !hasQuotes, !hasReplacesPattern, !containsOriginal, !containsSuggested {
                return trimmed
            }

            // Log that we're sanitizing
            Logger.debug("Sanitizing verbose explanation (\(wordCount) words, hasQuotes=\(hasQuotes), hasReplaces=\(hasReplacesPattern))", category: Logger.llm)

            // Try to extract a meaningful part if possible
            // Look for common useful phrases at the end
            let usefulSuffixes = ["for clarity", "for conciseness", "for readability", "more direct", "clearer", "simpler"]
            for suffix in usefulSuffixes {
                if lowerExplanation.hasSuffix(suffix) || lowerExplanation.hasSuffix(suffix + ".") {
                    return "Improves \(suffix)"
                }
            }

            // Generate a generic but helpful explanation based on the change
            let lengthDiff = original.count - suggested.count
            if lengthDiff > 10 {
                return "More concise phrasing"
            } else if lengthDiff < -10 {
                return "Clearer expression"
            } else {
                return "Improves readability"
            }
        }

        /// Build diff segments showing what changed between original and suggested
        /// Uses Swift's built-in CollectionDifference with Myers's algorithm
        private func buildDiffSegments(original: String, suggested: String) -> [DiffSegmentModel] {
            // Normalize quotes before diffing to avoid false positives from smart quotes
            let normalizedOriginal = normalizeQuotes(original)
            let normalizedSuggested = normalizeQuotes(suggested)

            // Split into tokens (words and whitespace separately)
            let originalTokens = splitIntoTokens(normalizedOriginal)
            let suggestedTokens = splitIntoTokens(normalizedSuggested)

            // Use Swift's built-in diff (Myers's algorithm)
            let diff = suggestedTokens.difference(from: originalTokens)

            // Build a map of changes by index
            var removals: Set<Int> = []
            var insertions: [Int: String] = [:]

            for change in diff {
                switch change {
                case let .remove(offset, _, _):
                    removals.insert(offset)
                case let .insert(offset, element, _):
                    insertions[offset] = element
                }
            }

            // Build segments by walking through both arrays
            var segments: [DiffSegmentModel] = []
            var origIdx = 0
            var suggIdx = 0

            while origIdx < originalTokens.count || suggIdx < suggestedTokens.count {
                // Handle insertions at current suggested position
                if let inserted = insertions[suggIdx] {
                    segments.append(DiffSegmentModel(text: inserted, kind: .added))
                    suggIdx += 1
                    continue
                }

                // Handle removals at current original position
                if origIdx < originalTokens.count, removals.contains(origIdx) {
                    segments.append(DiffSegmentModel(text: originalTokens[origIdx], kind: .removed))
                    origIdx += 1
                    continue
                }

                // Unchanged token
                if origIdx < originalTokens.count, suggIdx < suggestedTokens.count {
                    segments.append(DiffSegmentModel(text: suggestedTokens[suggIdx], kind: .unchanged))
                    origIdx += 1
                    suggIdx += 1
                } else {
                    break
                }
            }

            // Merge consecutive segments of the same kind
            return mergeSegments(segments)
        }

        /// Split text into tokens where words and whitespace are separate
        /// This ensures diff only marks words as changed, not surrounding spaces
        private func splitIntoTokens(_ text: String) -> [String] {
            var tokens: [String] = []
            var current = ""
            var isInWhitespace = false

            for char in text {
                let charIsWhitespace = char.isWhitespace

                if current.isEmpty {
                    // Starting a new token
                    current.append(char)
                    isInWhitespace = charIsWhitespace
                } else if charIsWhitespace == isInWhitespace {
                    // Same type as current token, continue
                    current.append(char)
                } else {
                    // Transition between word and whitespace
                    tokens.append(current)
                    current = String(char)
                    isInWhitespace = charIsWhitespace
                }
            }

            if !current.isEmpty {
                tokens.append(current)
            }

            return tokens
        }

        /// Merge consecutive segments of the same kind for cleaner display
        private func mergeSegments(_ segments: [DiffSegmentModel]) -> [DiffSegmentModel] {
            guard !segments.isEmpty else { return [] }

            var result: [DiffSegmentModel] = []
            var current = segments[0]

            for segment in segments.dropFirst() {
                if segment.kind == current.kind {
                    current = DiffSegmentModel(text: current.text + segment.text, kind: current.kind)
                } else {
                    result.append(current)
                    current = segment
                }
            }
            result.append(current)

            return result
        }

        /// Normalize smart quotes and other typography to plain ASCII equivalents
        /// This prevents false diff positives from quote style differences
        private func normalizeQuotes(_ text: String) -> String {
            var result = text
            // Smart single quotes to straight apostrophe
            result = result.replacingOccurrences(of: "\u{2019}", with: "'") // Right single quote
            result = result.replacingOccurrences(of: "\u{2018}", with: "'") // Left single quote
            result = result.replacingOccurrences(of: "\u{201B}", with: "'") // Single high-reversed-9
            // Smart double quotes to straight quote
            result = result.replacingOccurrences(of: "\u{201C}", with: "\"") // Left double quote
            result = result.replacingOccurrences(of: "\u{201D}", with: "\"") // Right double quote
            result = result.replacingOccurrences(of: "\u{201E}", with: "\"") // Double low-9
            // Dashes to hyphen
            result = result.replacingOccurrences(of: "\u{2013}", with: "-") // En dash
            result = result.replacingOccurrences(of: "\u{2014}", with: "-") // Em dash
            return result
        }
    }

    @available(macOS 26.0, *)
    extension FMStyleAnalysisResult {
        /// Convert all suggestions to StyleSuggestionModel array
        /// - Parameters:
        ///   - text: The original text that was analyzed
        ///   - style: The writing style that was used
        /// - Returns: Array of valid StyleSuggestionModel (filtering out any with invalid positions and overlapping ranges)
        func toStyleSuggestionModels(in text: String, style: WritingStyle) -> [StyleSuggestionModel] {
            // Convert all suggestions to models
            let allModels = suggestions.compactMap { $0.toStyleSuggestionModel(in: text, style: style) }

            // Filter out overlapping suggestions
            // When suggestions overlap, keep the first one (by position) and discard overlapping ones
            return filterOverlappingSuggestions(allModels)
        }

        /// Filter out suggestions that overlap with each other
        /// Keeps suggestions in position order, discarding any that overlap with already-kept suggestions
        private func filterOverlappingSuggestions(_ suggestions: [StyleSuggestionModel]) -> [StyleSuggestionModel] {
            guard suggestions.count > 1 else { return suggestions }

            // Sort by start position
            let sorted = suggestions.sorted { $0.originalStart < $1.originalStart }

            var result: [StyleSuggestionModel] = []

            for suggestion in sorted {
                // Check if this suggestion overlaps with any already-kept suggestion
                let overlaps = result.contains { existing in
                    rangesOverlap(
                        start1: existing.originalStart, end1: existing.originalEnd,
                        start2: suggestion.originalStart, end2: suggestion.originalEnd
                    )
                }

                if !overlaps {
                    result.append(suggestion)
                } else {
                    Logger.debug("Filtering overlapping style suggestion at \(suggestion.originalStart)-\(suggestion.originalEnd)", category: Logger.analysis)
                }
            }

            return result
        }

        /// Check if two ranges overlap
        /// Ranges are [start, end) - end is exclusive
        private func rangesOverlap(start1: Int, end1: Int, start2: Int, end2: Int) -> Bool {
            // Two ranges overlap if start1 < end2 AND start2 < end1
            start1 < end2 && start2 < end1
        }
    }

    // MARK: - Text Generation @Generable Types

    /// Result of text generation from Foundation Models
    @available(macOS 26.0, *)
    @Generable
    struct FMTextGenerationResult {
        @Guide(description: """
        The generated text based on the user's instruction and context.
        This should be ready to insert directly into the document.
        Match the writing style specified in the prompt.
        Do not include explanations or meta-commentary - just the text to insert.
        """)
        let generatedText: String
    }

    // MARK: - Sentence Simplification @Generable Types

    /// Result of sentence simplification from Foundation Models
    @available(macOS 26.0, *)
    @Generable
    struct FMSentenceSimplificationResult {
        @Guide(description: """
        A single simplified version of the sentence in an array.
        The alternative should:
        - Be simpler and easier to read than the original
        - Preserve the core meaning
        - Use shorter words and sentences
        - Use active voice when possible
        If the sentence cannot be simplified meaningfully, return an empty array.
        """)
        let alternatives: [String]
    }

    /// Result of readability tips generation from Foundation Models
    @available(macOS 26.0, *)
    @Generable
    struct FMReadabilityTipsResult {
        @Guide(description: """
        2-3 concise, high-level tips to improve readability.
        Each tip must:
        - Be under 15 words
        - NOT quote or repeat any text from the user
        - Describe patterns (e.g., "2 long sentences" not "the sentence about X")
        - Be actionable but general
        Return empty array if text is well-written.
        """)
        let tips: [String]
    }

#endif
